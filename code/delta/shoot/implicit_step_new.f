C     nu-stage Implicit Runge-Kutta (2nu-order), solved by iteration

      subroutine implicit_step(ny, xin, yin, xout, yout,
     $     derivs, nu, crit, maxits, itsreach, 
     $     junkc, junkf1, junkf2)

      implicit none
      integer ny, nu, maxits, itsreach
      double precision xin, yin(ny), xout, yout(ny), crit
      external derivs
      double precision junkc, junkf1(ny), junkf2(ny), junkf3(ny)

      integer nymax, numax
      include '../nymax.inc'

      parameter(numax=3)
      double precision xi(nymax,numax), xiold(nymax,numax), 
     $   norminfdiff, norm2diff, pointdiff, crit10
      double precision dx, x(numax), f(nymax,numax)
      double precision a(numax,numax), b(numax), c(numax)

      integer i, ii, j, its

      integer ndivs, div
      logical repeat
      double precision y(nymax)

      if (ny .gt. nymax) stop 'nymax too small in implicit_step'

C     Define IRK nu=1,2,3
      if (nu.eq.1) then
         a(1,1) = 0.5d0
         b(1) = 1.d0
         c(1) = 0.5d0
      else if (nu.eq.2) then
         a(1,1) = 0.25d0
         a(1,2) = 0.25d0 - 0.5d0 / sqrt(3.d0)
         a(2,1) = 0.25d0 + 0.5d0 / sqrt(3.d0)
         a(2,2) = 0.25d0
         b(1) = 0.5d0
         b(2) = 0.5d0
         c(1) = 0.5d0 - 0.5d0 / sqrt(3.d0)
         c(2) = 0.5d0 + 0.5d0 / sqrt(3.d0)
      else if (nu.eq.3) then
         a(1,1) = 5.d0/36.d0
         a(1,2) = 2.d0/9.d0 - 1.d0/sqrt(15.d0)
         a(1,3) = 5.d0/36.d0 - 0.5d0/sqrt(15.d0)
         a(2,1) = 5.d0/36.d0 + sqrt(15.d0)/24.d0
         a(2,2) = 2.d0/9.d0
         a(2,3) = 5.d0/36.d0 - sqrt(15.d0)/24.d0
         a(3,1) = 5.d0/36.d0 + 0.5d0/sqrt(15.d0)
         a(3,2) = 2.d0/9.d0 + 1.d0/sqrt(15.d0)
         a(3,3) = 5.d0/36.d0
         b(1) = 5.d0/18.d0
         b(2) = 4.d0/9.d0
         b(3) = 5.d0/18.d0
         c(1) = 0.5d0 - sqrt(15.d0)/10.d0
         c(2) = 0.5d0
         c(3) = 0.5d0 + sqrt(15.d0)/10.d0
      else
         write(*,*) 'IRK nu=', nu, ' not implemented in implicit_step.'
         stop
      end if

      ndivs=1
      
C     Start new calculation
 1    continue

      do j=1,ny
         y(j) = yin(j)
      end do
      repeat = .FALSE.

      do div=1, ndivs

C     Collocation points
      dx = ( xout - xin ) / ndivs
      do i=1,nu
         x(i) = xin + dx * (div-1) + dx * c(i)
      end do

C     Zeroth-order estimates
      do j=1,ny
         do i=1,nu
            xi(j,i) = y(j)
         end do
      end do

      do its=1,maxits
C      do its=1,1   
C         if (its.gt.maxits*9/10) then
c           write(*,*) 'its= ', its, ' in implicitstep at x= ', xin,
c    $                 ' with err= ', norm2diff
C         end if
C        Store values of stages from previous iteration
         do j=1,ny
            do i=1,nu
               xiold(j,i) = xi(j,i)
            end do
         end do
C        Evaluate derivatives f at stages xi
         do i=1,nu
C            do j=1,nu
C               write(6,*) j,', ',xi(1,j)
C            end do
C           Inner patch: junk is irrelevant
C           Outer patch: junkc=Delta, junkf1=xi, junkf2=dxidtau
C           Future patch: junkc=Delta, junkf's are irrelevant
            call derivs(ny, xi(1,i), x(i), f(1,i), junkc, junkf1,junkf2) 
            
         end do
         
C         call derivs(ny, y, xin, junkf1, junkc, junkf3,junkf2)
                
C        Calculate new stages
         do j=1,ny
            do i=1,nu
               xi(j,i) = y(j)
               do ii=1,nu
                  xi(j,i) = xi(j,i) + dx * a(i,ii) * f(j,ii)
               end do
            end do
         end do
C        2-Norm of difference
         norm2diff = 0.d0
         do j=1,ny
            do i=1,nu
               norm2diff = norm2diff + (xiold(j,i)-xi(j,i))**2
            end do
         end do
         norm2diff = sqrt( norm2diff / nu / ny )
         write(6,*) "error: ", norm2diff
C        
         if (norm2diff .lt. crit) goto 2
         
      end do
      
c     write(6,*) 'x =', xin
      repeat = .TRUE.
c     stop 'implicitstep does not converge'
      
C     The program only branches here when the iteration has converged.
 2    continue
      
C      itsreach = max( its, itsreach )
C      write(*,*) 'its=', its, ' at x=', xin
      
C     Evaluate new value of y
      do j=1,ny
         do i=1,nu
            y(j) = y(j) + dx * b(i) * f(j,i)
         end do
         yout(j) = y(j)
      end do

C     End div cycle
      end do

      if (repeat) then 
         ndivs= ndivs * 2
         write(*,*) 'Using ndvis=', ndivs, ' at x=',xin
         goto 1
      else
      end if

      return

      end

